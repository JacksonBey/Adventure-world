<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Player Movement with Tiled Background</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Hide scrollbars */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Ensure full viewport height */
            background-color: #333; /* Darker background for contrast */
            font-family: 'Arial', sans-serif; /* Basic font */
        }
        canvas {
            border: 2px solid #555; /* Slightly thicker border */
            background-color: #fff; /* White background for the canvas (will be covered by tiles) */
            display: block; /* Remove extra space below canvas */
            box-shadow: 0 0 10px rgba(0,0,0,0.5); /* Add a subtle shadow to the canvas */
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        // Get the canvas element from the HTML
        const canvas = document.getElementById('gameCanvas');
        // Get the 2D rendering context for the canvas
        const ctx = canvas.getContext('2d');

        // Tile properties
        const TILE_SIZE = 40; // Size of each grass tile in pixels
        const TILE_COLOR_LIGHT = '#6aa84f'; // A lighter green for tiles
        const TILE_COLOR_DARK = '#5a943f';  // A darker green for a checkerboard pattern

        // Player properties
        const player = {
            x: 0,          // Player's x position (will be calculated)
            y: 0,          // Player's y position (will be calculated)
            width: 30,     // Width of the player sprite (slightly smaller)
            height: 30,    // Height of the player sprite (slightly smaller)
            color: 'orange', // Player color
            speed: 4       // Movement speed of the player (pixels per frame)
        };

        // Object to keep track of pressed keys
        const keysPressed = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            // For WASD controls (optional)
            w: false, a: false, s: false, d: false
        };

        /**
         * Handles keydown events to set the corresponding key state to true.
         * @param {KeyboardEvent} event - The keyboard event object.
         */
        function keyDownHandler(event) {
            const key = event.key.toLowerCase(); // Normalize key to lowercase for WASD
            if (event.key in keysPressed) { // Arrow keys
                keysPressed[event.key] = true;
                event.preventDefault();
            } else if (key in keysPressed) { // WASD keys
                keysPressed[key] = true;
                event.preventDefault();
            }
        }

        /**
         * Handles keyup events to set the corresponding key state to false.
         * @param {KeyboardEvent} event - The keyboard event object.
         */
        function keyUpHandler(event) {
            const key = event.key.toLowerCase();
            if (event.key in keysPressed) {
                keysPressed[event.key] = false;
                event.preventDefault();
            } else if (key in keysPressed) {
                keysPressed[key] = false;
                event.preventDefault();
            }
        }

        /**
         * Updates the player's position based on currently pressed keys.
         * Also handles boundary collision to keep the player within the canvas.
         */
        function updatePlayerPosition() {
            // Move player based on pressed keys (Arrow keys or WASD)
            if (keysPressed.ArrowUp || keysPressed.w) {
                player.y -= player.speed;
            }
            if (keysPressed.ArrowDown || keysPressed.s) {
                player.y += player.speed;
            }
            if (keysPressed.ArrowLeft || keysPressed.a) {
                player.x -= player.speed;
            }
            if (keysPressed.ArrowRight || keysPressed.d) {
                player.x += player.speed;
            }

            // Boundary checks to keep player within canvas
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
            if (player.y < 0) player.y = 0;
            if (player.y + player.height > canvas.height) player.y = canvas.height - player.height;
        }

        /**
         * Function to draw the tiled background map.
         */
        function drawMap() {
            for (let y = 0; y < canvas.height; y += TILE_SIZE) {
                for (let x = 0; x < canvas.width; x += TILE_SIZE) {
                    // Determine tile color for a checkerboard pattern
                    const tileX = Math.floor(x / TILE_SIZE);
                    const tileY = Math.floor(y / TILE_SIZE);
                    if ((tileX + tileY) % 2 === 0) {
                        ctx.fillStyle = TILE_COLOR_LIGHT;
                    } else {
                        ctx.fillStyle = TILE_COLOR_DARK;
                    }
                    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                }
            }
        }

        /**
         * Function to draw the player sprite on the canvas.
         */
        function drawPlayer() {
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x, player.y, player.width, player.height);
            // Add a simple border to the player for better visibility
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.strokeRect(player.x, player.y, player.width, player.height);
        }

        /**
         * Main game loop. Clears the canvas, updates game state, and redraws.
         */
        function gameLoop() {
            // Clear the entire canvas (optional if map covers everything, but good practice)
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawMap();              // Draw the background map first
            updatePlayerPosition(); // Update player's state
            drawPlayer();           // Draw the player on top of the map

            requestAnimationFrame(gameLoop); // Request the next frame
        }

        /**
         * Function to resize the canvas and re-center the player.
         * Called on initial load and when the window is resized.
         */
        function resizeCanvas() {
            const aspectRatio = 16 / 9; // Example aspect ratio
            let newWidth = window.innerWidth * 0.8;
            let newHeight = window.innerHeight * 0.8;

            // Adjust to maintain aspect ratio (optional, but can look better)
            if (newWidth / newHeight > aspectRatio) {
                newWidth = newHeight * aspectRatio;
            } else {
                newHeight = newWidth / aspectRatio;
            }

            canvas.width = newWidth;
            canvas.height = newHeight;


            // Center player only if it's the first load or if desired on resize
            // For now, we'll re-center. If the map was scrollable, this logic would change.
            if (!player.initialPositionSet) { // Check if initial position has been set
                 player.x = (canvas.width - player.width) / 2;
                 player.y = (canvas.height - player.height) / 2;
                 player.initialPositionSet = true; // Mark that initial position is set
            } else {
                // If resizing, ensure player stays within new bounds if they were near an edge
                if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
                if (player.y + player.height > canvas.height) player.y = canvas.height - player.height;
                if (player.x < 0) player.x = 0;
                if (player.y < 0) player.y = 0;
            }

            // The gameLoop will handle redrawing the map and player
        }

        /**
         * Initialization function.
         */
        function init() {
            document.addEventListener('keydown', keyDownHandler);
            document.addEventListener('keyup', keyUpHandler);

            player.initialPositionSet = false; // Flag to help with initial centering
            resizeCanvas(); // Set initial canvas size and player position

            window.addEventListener('resize', resizeCanvas); // Handle window resizing

            gameLoop(); // Start the game loop
        }

        // Call the init function when the window is fully loaded
        window.onload = init;
    </script>
</body>
</html>
