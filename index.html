<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scrolling Camera and Larger World</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #2c2c2c; /* Even darker background */
            font-family: 'Arial', sans-serif;
        }
        canvas {
            border: 3px solid #666; /* Thicker, more prominent border */
            background-color: #000; /* Black background for canvas before map draws */
            display: block;
            box-shadow: 0 0 15px rgba(0,0,0,0.7);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        // Get the canvas element and 2D rendering context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // World and Tile properties
        const TILE_SIZE = 40;
        const TILE_COLOR_LIGHT = '#7db860'; // Slightly brighter light green
        const TILE_COLOR_DARK = '#6ca050';  // Slightly brighter dark green
        const WORLD_COLS = 60; // Number of tile columns in the world
        const WORLD_ROWS = 40; // Number of tile rows in the world
        const worldWidth = WORLD_COLS * TILE_SIZE;
        const worldHeight = WORLD_ROWS * TILE_SIZE;

        // Player properties
        const player = {
            x: worldWidth / 2,  // Initial x position in world coordinates
            y: worldHeight / 2, // Initial y position in world coordinates
            width: 30,
            height: 30,
            color: '#ff8c00', // DarkOrange
            speed: 4,
            // No initialPositionSet needed anymore as position is absolute in the world
        };

        // Camera object to manage the viewport
        const camera = {
            x: 0, // Top-left x-coordinate of the camera in world space
            y: 0, // Top-left y-coordinate of the camera in world space
            width: canvas.width,  // These will be updated by resizeCanvas
            height: canvas.height // These will be updated by resizeCanvas
        };

        // Key tracking object
        const keysPressed = {
            ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
            w: false, a: false, s: false, d: false
        };

        /**
         * Handles keydown events.
         * @param {KeyboardEvent} event - The keyboard event.
         */
        function keyDownHandler(event) {
            const key = event.key.toLowerCase();
            if (event.key in keysPressed) keysPressed[event.key] = true;
            else if (key in keysPressed) keysPressed[key] = true;
            if (keysPressed.ArrowUp || keysPressed.ArrowDown || keysPressed.ArrowLeft || keysPressed.ArrowRight ||
                keysPressed.w || keysPressed.a || keysPressed.s || keysPressed.d) {
                event.preventDefault(); // Prevent scrolling only if a movement key is pressed
            }
        }

        /**
         * Handles keyup events.
         * @param {KeyboardEvent} event - The keyboard event.
         */
        function keyUpHandler(event) {
            const key = event.key.toLowerCase();
            if (event.key in keysPressed) keysPressed[event.key] = false;
            else if (key in keysPressed) keysPressed[key] = false;
        }

        /**
         * Updates the player's position based on input and world boundaries.
         */
        function updatePlayerPosition() {
            let dx = 0;
            let dy = 0;

            if (keysPressed.ArrowUp || keysPressed.w) dy -= player.speed;
            if (keysPressed.ArrowDown || keysPressed.s) dy += player.speed;
            if (keysPressed.ArrowLeft || keysPressed.a) dx -= player.speed;
            if (keysPressed.ArrowRight || keysPressed.d) dx += player.speed;

            // Update player position
            player.x += dx;
            player.y += dy;

            // World boundary checks for the player
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > worldWidth) player.x = worldWidth - player.width;
            if (player.y < 0) player.y = 0;
            if (player.y + player.height > worldHeight) player.y = worldHeight - player.height;
        }

        /**
         * Updates the camera's position to follow the player, clamped to world boundaries.
         */
        function updateCameraPosition() {
            // Target camera position to center the player
            let targetX = player.x + player.width / 2 - camera.width / 2;
            let targetY = player.y + player.height / 2 - camera.height / 2;

            // Clamp camera position to world boundaries
            camera.x = Math.max(0, Math.min(targetX, worldWidth - camera.width));
            camera.y = Math.max(0, Math.min(targetY, worldHeight - camera.height));
        }

        /**
         * Draws the visible portion of the tiled background map.
         */
        function drawMap() {
            // Calculate the range of tiles to draw based on camera position
            const startCol = Math.floor(camera.x / TILE_SIZE);
            const endCol = Math.min(WORLD_COLS -1 , Math.floor((camera.x + camera.width) / TILE_SIZE));
            const startRow = Math.floor(camera.y / TILE_SIZE);
            const endRow = Math.min(WORLD_ROWS -1, Math.floor((camera.y + camera.height) / TILE_SIZE));

            for (let row = startRow; row <= endRow; row++) {
                for (let col = startCol; col <= endCol; col++) {
                    const tileX = col * TILE_SIZE;
                    const tileY = row * TILE_SIZE;

                    // Determine tile color for a checkerboard pattern
                    if ((col + row) % 2 === 0) {
                        ctx.fillStyle = TILE_COLOR_LIGHT;
                    } else {
                        ctx.fillStyle = TILE_COLOR_DARK;
                    }
                    // Draw tile relative to camera
                    ctx.fillRect(tileX - camera.x, tileY - camera.y, TILE_SIZE, TILE_SIZE);
                }
            }
        }

        /**
         * Draws the player sprite relative to the camera.
         */
        function drawPlayer() {
            ctx.fillStyle = player.color;
            // Draw player relative to camera
            ctx.fillRect(player.x - camera.x, player.y - camera.y, player.width, player.height);

            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.strokeRect(player.x - camera.x, player.y - camera.y, player.width, player.height);
        }

        /**
         * Main game loop.
         */
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

            updatePlayerPosition(); // Update player based on input and world bounds
            updateCameraPosition(); // Update camera to follow player

            drawMap();              // Draw visible part of the map
            drawPlayer();           // Draw player relative to camera

            requestAnimationFrame(gameLoop);
        }

        /**
         * Resizes the canvas and updates camera dimensions.
         */
        function resizeCanvas() {
            const aspectRatio = 16 / 9;
            let newWidth = window.innerWidth * 0.75; // Slightly smaller canvas for better focus
            let newHeight = window.innerHeight * 0.75;

            if (newWidth / newHeight > aspectRatio) {
                newWidth = newHeight * aspectRatio;
            } else {
                newHeight = newWidth / aspectRatio;
            }

            canvas.width = newWidth;
            canvas.height = newHeight;

            // Update camera dimensions
            camera.width = canvas.width;
            camera.height = canvas.height;

            // Ensure player is correctly positioned if world is smaller than canvas (edge case)
            player.x = Math.min(player.x, worldWidth - player.width);
            player.y = Math.min(player.y, worldHeight - player.height);
            if (player.x < 0) player.x = 0;
            if (player.y < 0) player.y = 0;


            // Initial camera position update after canvas size is known
            // This will also handle clamping if the world is smaller than the canvas
            updateCameraPosition();
        }

        /**
         * Initialization function.
         */
        function init() {
            document.addEventListener('keydown', keyDownHandler);
            document.addEventListener('keyup', keyUpHandler);

            resizeCanvas(); // Set initial canvas and camera size

            window.addEventListener('resize', resizeCanvas);

            // Set player's initial position more thoughtfully within the world.
            // If the world is smaller than the canvas in any dimension, player is at 0,0.
            player.x = Math.max(0, (worldWidth - player.width) / 2);
            player.y = Math.max(0, (worldHeight - player.height) / 2);

            // Ensure camera is correctly positioned initially
            updateCameraPosition();

            gameLoop();
        }

        window.onload = init;
    </script>
</body>
</html>
